---
title: "Day 8 Lecture"
output: html_document
---

# Today's agenda
  - questions/review
  - if/else
  - for-loops
    - counters (sets)
    - "growing" results
    - debugging
    - break, next
  - simulating data
  - "roll your own" power analysis

# Questions/review?

# if/else
  - form: if(LOGICAL TEST) { CODE BLOCK if TEST == TRUE  }
  -       else if(OPTIONAL ADDITIONAL TEST) { CODE BLOCK if TRUE }
  - "else" code only tested if initial "if" fails
  - NOTE: "else" MUST be on same line as "}" that closes initial "if" block

```{r}
# simple examples

```

  - compare with `ifelse()`
    - arguments are: test = [LOGICAL TEST], yes = [VALUE if TEST == TRUE], no = [VALUE if TEST == FALSE]

```{r} 


```

# PRACTICE #1 & #2

# `for` loops
  - simple way to iterate through a set of code, via a "counter" variable
  - avoid re-writing code, when possible!

```{r}
# basic structure of a loop

# going from copy-paste to a loop

```

# Some tips for loops

```{r}
# "Poor man's progress bar"


# using get() to access objects programmatically
ggplot(iris, aes(Sepal.Width)) + geom_histogram()
ggplot(iris, aes("Sepal.Width")) + geom_histogram()
ggplot(iris, aes(get("Sepal.Width"))) + geom_histogram()

# you need explicit "print" statements inside loops
for(this.dim in colnames(iris)[1:4]) {
  
}

# also for plots!
for(this.dim in colnames(iris)[1:4]) {
  
}

```


# PRACTICE #3 & #4

# Building up to a power analysis via simulation
  - simulate fake data under some parameters
  - perform test
  - examine results of many iterations

```{r}
# quick review of d/p/q/r* family of distribution functions
?rnorm

x <- sort(rnorm(1000))
summary(x)
sd(x)
hist(x)
plot(x)
plot(dnorm(x) ~ x)
plot(pnorm(x) ~ x)
plot(qnorm(seq(0, 1, .01)) ~ seq(0, 1, .01))

2*(1-pnorm(abs(1.96)))

# simulating correlations with MASS
library(MASS) # look out for "masking" of select() from dplyr
cor.table <- matrix(c(1, .2, .2, 1), nrow = 2)
cor.table
some.data <- mvrnorm(n = 10, mu = c(1, 2), Sigma = cor.table, empirical = FALSE)
some.data
summary(some.data)
cor(some.data[, 1], some.data[, 2])
as.data.frame(some.data)


```

## Step 1: write the code for one basic "iteration" of a loop

```{r}
# simulate data


# perform test


```

## Step 2: figure out how you are going to store the results of each loop
  - "pre-allocate" an object to act as the "results container"
  - modify your one-time code to "fill in" part of that container

```{r}


```

## Step 3: put code into a loop structure and test it out with a few iterations
  - make a "progress bar" if you want

```{r}


```

## Step 4: run it "for real" with full # of iterations

```{r}


```


# Power analysis
  - set up parameters of simulation
  - run simulation loop
  - process/analyze results

```{r}


```

Going further: looping over sets of simulations!
  - loops within loops

```{r}
# simple loop within loop

# nested loops in power simulation

```

# Troubleshooting loops
  - build incrementally
  - "manually" set counter, step through code inside loop
  - if you hit a snag, use "last value" of counter to identify where you hit that snag

```{r}


```

# PRACTICE #4